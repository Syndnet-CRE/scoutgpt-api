const propertyService = require('./propertyService');
const spatialService = require('./spatialService');
const { parseBbox } = require('../utils/normalize');
const { buildSystemPrompt } = require('../knowledge/system-prompt');

const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
const CLAUDE_MODEL = 'claude-sonnet-4-20250514';

const tools = [
  {
    name: 'search_properties',
    description: `Search for properties in Travis County with filters. Returns up to \`limit\` properties with attomId, address, property type, year built, beds/baths, building area, lot size, assessed value, last sale date/price, plus GIS data (zoning, flood zone, infrastructure distances). Use bbox for map viewport searches, zipCode for ZIP-based searches.

CRITICAL — propertyType MUST use these ATTOM numeric codes (comma-separated for asset classes):
• Multifamily/Apartments: "369,373,378,370,368" (includes apartments, duplexes, triplexes, large complexes)
• Office: "167,361,178" (mid-size, urban, small office)
• Retail: "169,139,359,184" (shopping centers, strip retail, power centers, malls)
• Industrial/Warehouse: "238,210,229,212" (light industrial, heavy industrial, distribution)
• Land/Vacant: "401,120,270" (residential lots, commercial land)
• Hotel/Hospitality: "160,161" (hotels, motels, resorts)
• Self-Storage: "339"
• Medical Office: "148"

NEVER pass text labels like "multifamily" or "COMMERCIAL" — ONLY numeric codes. When user mentions an asset class, ALWAYS pass the full comma-separated code list for that class.`,
    input_schema: {
      type: 'object',
      properties: {
        bbox: { type: 'string', description: 'Bounding box as "minLng,minLat,maxLng,maxLat". Use for map viewport searches.' },
        zipCode: { type: 'string', description: 'ZIP code (e.g., "78701")' },
        city: { type: 'string', description: 'City name filter (partial match, e.g., "Austin", "Round Rock")' },
        propertyType: { type: 'string', description: 'ATTOM numeric codes, comma-separated. REQUIRED when user specifies asset class. Use FULL code lists: Multifamily="369,373,378,370,368", Office="167,361,178", Retail="169,139,359,184", Industrial="238,210,229,212", Land="401,120,270", Hotel="160,161", Storage="339", Medical="148". NEVER pass text labels — only numeric codes.' },
        minAcres: { type: 'number', description: 'Minimum lot size in acres' },
        maxAcres: { type: 'number', description: 'Maximum lot size in acres' },
        minValue: { type: 'number', description: 'Minimum assessed value in dollars' },
        maxValue: { type: 'number', description: 'Maximum assessed value in dollars' },
        absenteeOwner: { type: 'boolean', description: 'Filter to absentee owners only' },
        ownerOccupied: { type: 'boolean', description: 'Filter to owner-occupied only' },
        corporateOwned: { type: 'boolean', description: 'Filter to corporate/company owned only' },
        foreclosure: { type: 'boolean', description: 'Filter to properties with foreclosure records' },
        taxDelinquent: { type: 'boolean', description: 'Filter to tax delinquent properties' },
        recentSales: { type: 'boolean', description: 'Filter to properties sold in last 12 months' },
        highEquity: { type: 'boolean', description: 'Filter to properties with high available equity' },
        zoningCodes: { type: 'string', description: 'Local zoning codes, comma-separated (e.g., "GR,CS,LI"). Matches zoning_local column.' },
        zoningCategory: { type: 'string', description: 'Broad zoning category: "residential", "commercial", "industrial", "mixed_use", or "agricultural". Maps to specific local zoning codes.' },
        jurisdiction: { type: 'string', description: 'Zoning jurisdiction filter (partial match, e.g., "Austin", "Travis County")' },
        excludeFloodplain: { type: 'boolean', description: 'Exclude properties in floodplain (in_floodplain = false or null)' },
        floodZones: { type: 'string', description: 'FEMA flood zones, comma-separated (e.g., "X,X500"). Common zones: X (minimal risk), A, AE, AO (high risk).' },
        maxWaterDistanceFt: { type: 'number', description: 'Maximum distance to nearest water line in feet' },
        minWaterDiameterIn: { type: 'number', description: 'Minimum water line diameter in inches' },
        maxSewerDistanceFt: { type: 'number', description: 'Maximum distance to nearest sewer line in feet' },
        maxStormDistanceFt: { type: 'number', description: 'Maximum distance to nearest storm drain in feet' },
        sortBy: { type: 'string', description: 'Sort results by: nearest_water_ft, nearest_sewer_ft, nearest_storm_ft, area_lot_acres, tax_assessed_value_total, area_building, last_sale_price, year_built' },
        sortOrder: { type: 'string', description: 'Sort direction: "asc" (default) or "desc"' },
        limit: { type: 'number', description: 'Number of results to return. Default 15, max 25.' },
      },
    },
  },
  {
    name: 'get_property_details',
    description: 'Get full property details by attom_id OR by address search. Returns ownership, tax assessments, sales history, current loans, AVM valuations, climate risk scores, building permits, flood zone, and school district data. Use this for site analysis, due diligence, investment analysis, owner research, and risk assessment. The property_use_standardized field contains a numeric ATTOM code — translate it to a CRE name before presenting to the user.',
    input_schema: {
      type: 'object',
      properties: {
        attomId: { type: 'string', description: 'ATTOM property ID' },
        address: { type: 'string', description: 'Street address to search for (e.g., "1102 S Congress Ave")' },
      },
    },
  },
  {
    name: 'get_market_stats',
    description: 'Get aggregate market statistics for an area (ZIP code or FIPS). Returns average assessed values, sale prices, building areas, lot sizes, and year built. Use for market snapshots, area comparisons, and submarket analysis.',
    input_schema: { type: 'object', properties: { zipCode: { type: 'string' }, fipsCode: { type: 'string' }, propertyType: { type: 'string', description: 'ATTOM numeric code to filter by property type' } } },
  },
  {
    name: 'spatial_query',
    description: 'Find properties within a radius of a point (latitude/longitude). Use for comparable sales searches, nearby property analysis, and surrounding area context. Default radius is 1000m (~0.6 miles). For comp searches use: 1609m (1 mile), 4828m (3 miles), 8047m (5 miles).',
    input_schema: { type: 'object', properties: { longitude: { type: 'number' }, latitude: { type: 'number' }, radiusMeters: { type: 'number', description: 'Search radius in meters. 1609=1mi, 4828=3mi, 8047=5mi' }, limit: { type: 'number' } }, required: ['longitude', 'latitude'] },
  },
];

async function executeTool(toolName, toolInput) {
  console.log(`[TOOL] ${toolName} called with:`, JSON.stringify(toolInput));

  switch (toolName) {
    case 'search_properties': {
      const bbox = toolInput.bbox ? parseBbox(toolInput.bbox) : null;
      const filters = { ...toolInput }; delete filters.bbox; delete filters.limit;
      console.log(`[SEARCH] Filters:`, JSON.stringify(filters));
      const result = await propertyService.searchProperties({ bbox, filters, limit: toolInput.limit || 15 });
      const count = Array.isArray(result.properties || result) ? (result.properties || result).length : 0;
      console.log(`[SEARCH] Returned ${count} results`);
      return result;
    }
    case 'get_property_details': {
      // Support address-based lookup: search first, then get details
      if (toolInput.address && !toolInput.attomId) {
        console.log(`[DETAILS] Address lookup: "${toolInput.address}"`);
        const searchResult = await propertyService.searchProperties({
          filters: {},
          limit: 1,
          addressSearch: toolInput.address,
        });
        const properties = searchResult.properties || searchResult;
        if (Array.isArray(properties) && properties.length > 0 && properties[0].attomId) {
          console.log(`[DETAILS] Found attomId: ${properties[0].attomId}`);
          return await propertyService.getPropertyDetail(properties[0].attomId);
        }
        return { error: 'No property found matching address: ' + toolInput.address };
      }
      return await propertyService.getPropertyDetail(toolInput.attomId);
    }
    case 'get_market_stats':
      return await propertyService.getMarketStats(toolInput);
    case 'spatial_query':
      return await spatialService.propertiesWithinRadius(toolInput.longitude, toolInput.latitude, toolInput.radiusMeters || 1000, toolInput.limit || 50);
    default:
      return { error: 'Unknown tool: ' + toolName };
  }
}

async function chat(messages, context = {}) {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) throw new Error('ANTHROPIC_API_KEY not configured');

  // Build CRE-aware system prompt with optional runtime context
  const systemPrompt = buildSystemPrompt(context);

  // Collect attom_ids from tool results
  const collectedProperties = [];

  let response = await callClaudeAPI(apiKey, systemPrompt, messages, tools);
  let iterations = 0;

  while (response.stop_reason === 'tool_use' && iterations < 3) {
    iterations++;
    const toolUseBlocks = response.content.filter(b => b.type === 'tool_use');
    const toolResults = [];

    for (const tu of toolUseBlocks) {
      try {
        const result = await executeTool(tu.name, tu.input);

        // Extract attom_ids from search results
        if (tu.name === 'search_properties' || tu.name === 'spatial_query') {
          const properties = result.properties || result;
          if (Array.isArray(properties)) {
            properties.forEach(p => {
              if (p.attomId) collectedProperties.push({ attomId: Number(p.attomId), latitude: p.latitude ? Number(p.latitude) : null, longitude: p.longitude ? Number(p.longitude) : null });
            });
          }
        }
        // Extract attom_id from single property detail
        if (tu.name === 'get_property_details' && result && result.attomId) {
          collectedProperties.push({ attomId: Number(result.attomId), latitude: result.latitude ? Number(result.latitude) : null, longitude: result.longitude ? Number(result.longitude) : null });
        }

        // Truncate large tool results to save tokens
        let resultStr = JSON.stringify(result);
        if (resultStr.length > 8000) {
          if (result.properties && Array.isArray(result.properties)) {
            result.properties = result.properties.slice(0, 20);
            result.truncated = true;
            result.originalCount = result.properties.length;
            resultStr = JSON.stringify(result);
          }
          if (resultStr.length > 12000) {
            resultStr = resultStr.substring(0, 12000) + '... [truncated]';
          }
        }
        toolResults.push({
          type: 'tool_result',
          tool_use_id: tu.id,
          content: resultStr,
        });
      } catch (error) {
        toolResults.push({
          type: 'tool_result',
          tool_use_id: tu.id,
          content: JSON.stringify({ error: error.message }),
          is_error: true,
        });
      }
    }

    const updatedMessages = [
      ...messages,
      { role: 'assistant', content: response.content },
      { role: 'user', content: toolResults },
    ];
    response = await callClaudeAPI(apiKey, systemPrompt, updatedMessages, tools);
  }

  const text = response.content
    .filter(b => b.type === 'text')
    .map(b => b.text)
    .join('\n');

  const seen = new Set();
  const uniqueProperties = collectedProperties.filter(p => {
    if (seen.has(p.attomId)) return false;
    seen.add(p.attomId);
    return true;
  });

  return { text, properties: uniqueProperties.map(p => p.attomId), propertyMarkers: uniqueProperties };
}

async function callClaudeAPI(apiKey, systemPrompt, messages, toolDefs) {
  const response = await fetch(CLAUDE_API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey, 'anthropic-version': '2023-06-01' },
    body: JSON.stringify({ model: CLAUDE_MODEL, max_tokens: 4096, system: systemPrompt, messages, tools: toolDefs }),
  });
  if (response.status === 429) {
    console.log('[CLAUDE] Rate limited — returning friendly message');
    return {
      stop_reason: 'end_turn',
      content: [{ type: 'text', text: "I'm processing a lot of data right now. Please wait about 30 seconds and try your query again." }],
    };
  }
  if (!response.ok) { const error = await response.text(); throw new Error('Claude API error: ' + response.status + ' - ' + error); }
  return await response.json();
}

module.exports = { chat, tools };
